package Challenge;
import java.io.*;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;

public class Solution {
	public static int[] result;
	public static Queue<subRange> queueInc = new PriorityQueue<subRange>();
    public static Queue<subRange> queueDec = new PriorityQueue<subRange>();
	public static HashMap<Integer, Integer> sumSubArray= new HashMap<Integer, Integer>();
	public static subRange first; 
	public static subRange last; 
	public static LinkedList<subRange> windowMiddle = new LinkedList<subRange>();
    public static void findLength(int[] nums) {
        if (nums == null || nums.length == 0) {
        	return ;
        }
        int n = nums.length;
        int[] dpInc = new int[n];
        int[] dpDec = new int[n];    
        dpInc[0] = 1; dpDec[0] = 1;
        int startInc = 0; int endInc = 0; int startDec = 0; int endDec = 0;
        boolean StateInc = false;	// whether the last element is in an increasing subArray
        boolean StateDec = false;	// whether the last element is in an decreasing subArray
        for (int i = 1; i < n; i++) {
        	/* take care of the last subArray
        	 * including the situation if it is end of two same elements
        	*/
        	if (i == n-1 && nums[i] != nums[i - 1]){
        		if (nums[i] > nums[i - 1] || StateInc && !StateDec) { queueInc.add(new subRange(startInc, i, true)); }
        		if (nums[i] < nums[i - 1] || !StateInc && StateDec) { queueDec.add(new subRange(startDec, i, false)); }
        	}
            if (nums[i] > nums[i - 1]) {
            	StateInc = true;
                dpInc[i] = dpInc[i - 1] + 1;
                dpDec[i] = 1;
                if (dpDec[i - 1] != 1) {  
                	endDec = i -1;
                	queueDec.add(new subRange(startDec, endDec, false));
                	StateDec = false;             	
                	startInc = i - 1;
                }
            }
            else if (nums[i] < nums[i - 1]){
            	StateDec = true;
            	dpDec[i] = dpDec[i - 1] + 1;
                dpInc[i] = 1;
                if (dpInc[i - 1] != 1){
                	endInc = i - 1;
                	queueInc.add(new subRange(startInc, endInc, true));
                	StateInc = false;
                	startDec = i - 1;
                }                
            }
            /* the following element is the same as the previous one */
            else {
            	if (StateInc){
                	endInc = i - 1;
                	queueInc.add(new subRange(startInc, endInc, true));
                	StateInc = false;
            	}
            	if (StateDec){
                	endDec = i -1;
                	queueDec.add(new subRange(startDec, endDec, false));
                	StateDec = false; /* No decreasing trend any more */
            	}
            	/* Since they are the same , so there is no trend anymore 
            	 * Just reInitalize dpInc, dpDec, startInc, startDec as the beginning of the array
            	 * */
            	dpInc[i] = 1; dpDec[i] = 1;
            	startInc = i; startDec = i;
            }
        }        
        System.out.println("check it");
    }
    public static int sumWithoutOne(int largestNum) {
    	int sum = 0;
    	do {
    		sum += --largestNum;
    	} while (largestNum > 0);
    	return sum;
    }
    public static subRange getNextEle(){
		subRange ele;
		if (queueInc.size() > 0 && queueDec.size() >0){
			if (queueInc.peek().start < queueDec.peek().start ){
				ele = queueInc.poll();
			} else {// add elements from Decrease queue	
				ele = queueDec.poll();				
			}			
		} else if (queueInc.size() > 0){
			ele = queueInc.poll();
		} else {
			ele = queueDec.poll();
		}
		int l = ele.length;
		if (!sumSubArray.containsKey(l)){
			// put <key, value> to the hashMap
			sumSubArray.put(l, sumWithoutOne(l));
		}
		return ele;	
    }
    public static subRange peekNextEle(){
		subRange ele;
		if (queueInc.size() > 0 && queueDec.size() >0){
			if (queueInc.peek().start < queueDec.peek().start ){
				ele = queueInc.peek();
			} else {// add elements from Decrease queue	
				ele = queueDec.peek();				
			}			
		} else if (queueInc.size() > 0){
			ele = queueInc.peek();
		} else {
			ele = queueDec.peek();
		}
		int l = ele.length;
		if (!sumSubArray.containsKey(l)){
			// put <key, value> to the hashMap
			sumSubArray.put(l, sumWithoutOne(l));
		}
		return ele;	
    }
    public static void changeResult(subRange sr, int index, boolean add){
    	/* add here means we want to add value to windowMiddle or minus value to it */
		if (sr.increase){
			if (add){
				result[index] += sumSubArray.get(sr.length);
			} else {
				result[index] -= sumSubArray.get(sr.length);
			}			
		}
		else {
			if (add){
				result[index] -= sumSubArray.get(sr.length);
			} else {
				result[index] += sumSubArray.get(sr.length);
			}
		}
    }
    /* Return exact last length exactl */
    public static int setFirstWindow(int K){		
    	/* Set first element */
		first = getNextEle();
		// update the result of first window 
		changeResult(first, 0, true);
		
		last = null;
		/* The whole window could only contains one element */
		if (first.length >= K){						
			return K;
		} else {
			/* There are three conditions:
			 * 1. normal condition: within the window, there are other subRange filled to windowMiddle even last
			 * 2. the rest elements are all the same so that there is to subRange following
			 * 3. the nearest subRange is out of window
			 * 
			 */
			if (queueInc.size() + queueDec.size()>0){
				subRange ele = peekNextEle();
				int firstIndex ;
				firstIndex = ele.start;
				while (firstIndex < K ) {
					ele = getNextEle();
					changeResult(ele, 0, true);
					windowMiddle.addLast(ele);	// add the element to windowMiddle
					if (ele.end >= K) {
						last = windowMiddle.pollLast();	// poll out the last in windowMiddle to last
						break;
					}	// find the last element
					ele = getNextEle();
					firstIndex = ele.start;					
				}
			}			
			int exactl = 0;
			if (last != null){
				// last element may exceed the window
				if (last.increase){ // if the last is a increase array, minus it then add the exact value
					int l = last.length;
					result[0] -= sumSubArray.get(l) ;
					exactl = ((K-1)-(last.start)+1);
					if (!sumSubArray.containsKey(exactl)){
						// put <key, value> to the hashMap
						sumSubArray.put(exactl, sumWithoutOne(exactl));
					}
					result[0] += sumSubArray.get(exactl);
				} else {//// else the last is a decrease array, add it then add the minus the exact value
					result[0] += sumSubArray.get(last.length) ;
					exactl = ((K-1)-(last.start)+1);
					if (!sumSubArray.containsKey(exactl)){
						// put <key, value> to the hashMap
						sumSubArray.put(exactl, sumWithoutOne(exactl));
					}
					result[0] -= sumSubArray.get(exactl);
				}
			}
			return exactl;
		}
    }
	public static int[] findPattern(int N, int K, int[] price){
		/* Key:n 
		 * Value: Sum of {1,2,..., n}, which refer to the number of its subArrays
		 */

		findLength(price);
		result = new int [N - K + 1];

		
		/* First subrange and last subRange could be affected by movements
		 * The middle don't 
		 */

		/* Set first window */
		int lastI = setFirstWindow(K);
		/* Initialize first value and last value */
		int FirstValue; int LastValue;
		if (last == null ) { //If the window contains only one subRange
			/* Three conditions:
			 * 1. First subArray exceed the window
			 * 2. No second subArray
			 * 3. second subArray exceeds the window
			 */
			FirstValue = first.increase? sumSubArray.get(Math.min(K, first.length)): - sumSubArray.get(Math.min(K, first.length)); 
			LastValue = 0;			
		} else {
			FirstValue = first.increase? sumSubArray.get(first.length): - sumSubArray.get(first.length); 
			LastValue = last.increase ? sumSubArray.get(lastI) : - sumSubArray.get(lastI);
		}

		for (int i = first.start + 1; i < N - K + 1; i++){
			/* window start index is i, window end index is i + K -1 */
			
			/* Update last if necessary */
			if (queueInc.size() + queueDec.size() > 0){
				
				if (last != null){
					if (last.end < i + K -1 || last.end == N - 1) {				
						// add elements from Increase queue
						subRange ele = getNextEle();
						windowMiddle.addLast(last);
						changeResult(last, i, true);
						// in case there is no element in windowMiddle
						last = ele;											
					}
				} else {
					subRange ele1 = peekNextEle();
					if (ele1.start < i - K + 1 ){
						subRange ele2 = getNextEle();
						last = ele2;
					}
					if (( ele1.end == N - 1 && i + K -1<=  ele1.start)){
						subRange ele2 = getNextEle();
						first = ele2;						
					}
				}
			}

			/* Update first if necessary */
			if (first != null && first.end -1 < i) {
				if (windowMiddle.size() > 0){					
					//Update windowMiddle by remove an old element
					first = windowMiddle.pollFirst();
					changeResult(first, i, false);					
				} else {
					// in case there only no element in windowMiddle
					// so that the last is the first as well
					first = last;
					last = null;
				}				
			}

			/* Calculate result[i] based on result[i - 1]
			 * Keep the sum of elements in windowMiddle
			 * Just update the sum of first and last
			 */
			int updatedFirstValue; int updatedLastValue;
			int firstI = i;
			if (first == null && last == null){
				result[i] = 0;
				FirstValue = 0;
				LastValue = 0;
			} else {
				if (first.start > i) firstI = first.start;
				if (last == null){

					if (first == null ||first.end - i + 1 <= 1){
						first = null;
						updatedFirstValue = 0;
					} else {
						int exactl = first.end - firstI + 1;
						if (!sumSubArray.containsKey(exactl)){
							// put <key, value> to the hashMap
							sumSubArray.put(exactl, sumWithoutOne(exactl));
						}
						updatedFirstValue = first.increase ? sumSubArray.get(first.end - firstI + 1) : -sumSubArray.get(first.end - firstI + 1);	
					}
					updatedLastValue = 0;
				} else {
					updatedFirstValue = first.increase ? sumSubArray.get(first.end - firstI + 1) : -sumSubArray.get(first.end - firstI + 1);			
					updatedLastValue = last.increase ? sumSubArray.get(i + K -1 - last.start + 1 ) : - sumSubArray.get(i +K -1 - last.start + 1 );							
				}
				
				result[i] += result[i - 1] + updatedFirstValue - FirstValue + updatedLastValue - LastValue;
				FirstValue = updatedFirstValue;
				LastValue = updatedLastValue;
			}
		}

		return result;
	}
	public static void main(String[] args) throws IOException {
		// we assume that the input.txt is located in the same directory of this Solution.java file
		InputStream inputstream = new FileInputStream("./src/Challenge/inputChengxi2.txt");
		@SuppressWarnings("resource")
		BufferedReader reader=new BufferedReader(new InputStreamReader(inputstream));
		if(reader.ready()){
			String[] line = reader.readLine().split(" ");
			int N = Integer.valueOf(line[0]);
			int K = Integer.valueOf(line[1]);
			line = reader.readLine().split(" ");
			int i = 0;
			int[] price = new int[line.length];
			while (i < line.length){
				price[i] = Integer.valueOf(line[i]);
				System.out.println(line[i++]);
			}
			int[] result = findPattern(N, K, price);
			OutputStream output = new BufferedOutputStream(new FileOutputStream("./src/Challenge/output.txt"));
			for (int j = 0; j < result.length; j++){
				output.write((String.valueOf(result[j])+" ").getBytes());
			}
			output.close();
			
			
		}
		
	}
}